<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>线程相关的面试题</title>
</head>
<body>
<div class="container">
Java 线程（Thread）有以下几种状态：
<code class="ibk">
    Java 线程（Thread）有以下几种状态：
    **新建状态 (New)**：当线程对象被创建后，即进入新建状态，例如，当你用new Thread()创建了一个线程实例之后，它就处于这种状态。
    **就绪状态 (Runnable)**：当调用线程对象的start()方法后，该线程处于就绪状态。Java 线程中把就绪状态和运行状态统一视为“可运行”状态，它表示线程已经可以运行了，但是由于线程调度器尚未把执行权交给它，它并没有运行。
    **运行状态 (Running)**：如果就绪状态的线程获取了 CPU，开始执行run()方法的 Java 线程代码，线程便处于运行状态。
    **阻塞状态 (Blocked)**：阻塞状态是指线程因为某种原因暂时放弃了 CPU 使用权，也即暂时停止运行。直到线程进入可运行状态，它才有机会再次获得 CPU 分配并继续其运行。阻塞的情况分几种情况：
    等待阻塞：运行的线程执行wait()方法，使线程进入到等待阻塞状态。
    同步阻塞：线程在获取synchrozs锁无法成功时，会进入同步阻塞状态。
    其他阻塞：通过调用线程的sleep()或join()或发出了I/O请求时，线程会进入阻塞状态。当sleep()状态超时，join()等待线程终止或者超时，或者I/O处理完毕时，线程重新转入就绪状态。
    **等待状态 (Waiting)**：线程执行了Object.wait(), Thread.join()或LockSupport.park()后，会使线程处于等待状态。在等待状态的线程需要被显式唤醒（比如调用了notify()/notifyAll()，join()完成），否则不会自行返回到可运行状态。
    **超时等待状态 (Timed Waiting)**：它是线程执行了Object.wait()、Thread.sleep()、Thread.join()中带时间的方法或LockSupport.parkNanos() / LockSupport.parkUntil()后，线程会进入超时等待状态。这个状态会在指定的时间过后自动返回到可运行状态，或者在超时结束前被唤醒。
    **终止状态 (Terminated)**：如果线程的run()方法执行完毕或者由于异常退出了run()方法，那么该线程结束生命周期，即处于终止状态。一个线程一旦终止，就不能复生。
</code>

什么情况会导致线程进入阻塞状态？
<code class="ibk">
    线程进入阻塞状态通常由以下几种情况引起：
    **同步阻塞 (Synchronized Block)**：当一个线程在访问某个同步控制块（使用synchronized关键字）尝试获取对象的锁时，如果该对象已被其他线程锁定，那么尝试获取锁的线程就会进入阻塞状态，直至锁被释放。
    **等待I/O完成 (Waiting for I/O)**：当线程执行I/O操作，如读写文件、网络通信等，因为这些操作通常比CPU计算慢得多，所以在等待I/O操作完成的过程中，线程会被阻塞。
    调用Object的wait()方法：当线程调用某个对象的wait()方法时，它会释放该对象的锁（如果有的话）并让线程进入等待状态。该线程会保持等待，直到其他线程调用相同对象的notify()或notifyAll()方法将其唤醒，或者是等待被中断。
    调用Thread的join()方法：当一个线程A执行另一个线程B的join()方法后，线程A将会被阻塞, 直至线程B结束生命周期后，线程A才会从join()调用返回并继续执行。
    调用Thread的sleep()方法：虽然调用sleep()方法通常被认为是让线程进入“休眠”或“暂停”状态，但实际上在睡眠期间，线程被阻塞，不会分配CPU时间，直到睡眠时间结束或被中断。
</code>

为什么线程在访问同步控制块时会进入阻塞状态？
<code class="ibk">
    当线程访问包含synchronized关键字的代码块（即同步控制块）时，线程需要首先获取该代码块关联对象的锁。为了保证代码的线程安全，Java语言引入了对象锁的概念，每一个对象都具有一个默认的内置锁，当多个线程需要访问同一段同步代码块时，Java虚拟机会控制只能有一个线程拥有该内置锁。
    如果该锁已经被其他线程获得，那么尝试访问同步控制块的线程将无法获取到锁，因而进入阻塞状态。只有当当前持有锁的线程退出同步控制块，从而释放锁时，正在等待的线程才有可能被唤醒并尝试重新获取锁，进入同步控制块。
    这个过程是为了保证线程在执行同步控制块代码的原子性，也就是避免在一个线程执行同步控制块的过程中，另一个线程同时修改了同一段代码操作的数据，从而影响了第一个线程的执行结果。这是实现多线程环境下数据一致性的一个重要手段。
</code>

是否有其他方式可以实现线程同步而不使用同步控制块？
<code class="ibk">
    volatile关键字：volatile关键字可以确保变量的可见性，当一个变量被声明为volatile之后，意味着线程每次访问变量时都会读取变量修改后的最新值。虽然volatile不执行互斥访问，但它可以保证任何一个线程在读变量时都能看到最新写入的值。
    **锁 (Locks)**：Java java.util.concurrent.locks包提供了比synchronized关键字更加复杂的锁机制。比如ReentrantLock，它具有完全互斥的锁定机制，还支持条件变量，能实现更细粒度的线程同步控制。
    **原子变量(java.util.concurrent.atomic)**：该包提供了一系列的原子操作类，例如AtomicInteger，AtomicLong，AtomicReference等，这些类使得执行单一操作的变量更新成为原子操作，进而可以在没有锁的情况下实现线程安全。
    **条件变量 (Condition)**：条件变量提供了一种线程之间协调通信的方式。比如，通过ReentrantLock创建一个Condition，线程可以在某个条件变量上调用await()方法进入等待状态，直到其他线程在该条件变量上调用signal()或signalAll()方法唤醒等待的线程。
    **并发集合 (java.util.concurrent包中的集合)**：该包还提供了线程安全的集合类，如ConcurrentHashMap、CopyOnWriteArrayList等，这些集合类中的操作可以安全地并发执行，无需担心线程同步问题。
    Semaphore信号量：信号量用于控制同时访问某个特定资源的操作数量，通过协调各个线程，以保证它们对共享资源的合理使用。
</code>

</div>

<link href="style/styles.css" rel="stylesheet">
<script src="js/script.js"></script>

</body>
</html>