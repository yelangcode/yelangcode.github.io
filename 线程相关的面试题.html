<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>线程相关的面试题</title>
</head>
<body>
<div class="container">
    Java 线程（Thread）有以下几种状态：
    <code class="ibk">
        Java 线程（Thread）有以下几种状态：
        **新建状态 (New)**：当线程对象被创建后，即进入新建状态，例如，当你用new Thread()创建了一个线程实例之后，它就处于这种状态。
        **就绪状态 (Runnable)**：当调用线程对象的start()方法后，该线程处于就绪状态。Java
        线程中把就绪状态和运行状态统一视为“可运行”状态，它表示线程已经可以运行了，但是由于线程调度器尚未把执行权交给它，它并没有运行。
        **运行状态 (Running)**：如果就绪状态的线程获取了 CPU，开始执行run()方法的 Java 线程代码，线程便处于运行状态。
        **阻塞状态 (Blocked)**：阻塞状态是指线程因为某种原因暂时放弃了 CPU 使用权，也即暂时停止运行。直到线程进入可运行状态，它才有机会再次获得
        CPU 分配并继续其运行。阻塞的情况分几种情况：
        等待阻塞：运行的线程执行wait()方法，使线程进入到等待阻塞状态。
        同步阻塞：线程在获取synchrozs锁无法成功时，会进入同步阻塞状态。
        其他阻塞：通过调用线程的sleep()或join()或发出了I/O请求时，线程会进入阻塞状态。当sleep()状态超时，join()等待线程终止或者超时，或者I/O处理完毕时，线程重新转入就绪状态。
        **等待状态 (Waiting)**：线程执行了Object.wait(),
        Thread.join()或LockSupport.park()后，会使线程处于等待状态。在等待状态的线程需要被显式唤醒（比如调用了notify()/notifyAll()，join()完成），否则不会自行返回到可运行状态。
        **超时等待状态 (Timed
        Waiting)**：它是线程执行了Object.wait()、Thread.sleep()、Thread.join()中带时间的方法或LockSupport.parkNanos() /
        LockSupport.parkUntil()后，线程会进入超时等待状态。这个状态会在指定的时间过后自动返回到可运行状态，或者在超时结束前被唤醒。
        **终止状态 (Terminated)**：如果线程的run()方法执行完毕或者由于异常退出了run()方法，那么该线程结束生命周期，即处于终止状态。一个线程一旦终止，就不能复生。
    </code>

    什么情况会导致线程进入阻塞状态？
    <code class="ibk">
        线程进入阻塞状态通常由以下几种情况引起：
        **同步阻塞 (Synchronized
        Block)**：当一个线程在访问某个同步控制块（使用synchronized关键字）尝试获取对象的锁时，如果该对象已被其他线程锁定，那么尝试获取锁的线程就会进入阻塞状态，直至锁被释放。
        **等待I/O完成 (Waiting for I/O)**：当线程执行I/O操作，如读写文件、网络通信等，因为这些操作通常比CPU计算慢得多，所以在等待I/O操作完成的过程中，线程会被阻塞。
        调用Object的wait()方法：当线程调用某个对象的wait()方法时，它会释放该对象的锁（如果有的话）并让线程进入等待状态。该线程会保持等待，直到其他线程调用相同对象的notify()或notifyAll()方法将其唤醒，或者是等待被中断。
        调用Thread的join()方法：当一个线程A执行另一个线程B的join()方法后，线程A将会被阻塞,
        直至线程B结束生命周期后，线程A才会从join()调用返回并继续执行。
        调用Thread的sleep()方法：虽然调用sleep()方法通常被认为是让线程进入“休眠”或“暂停”状态，但实际上在睡眠期间，线程被阻塞，不会分配CPU时间，直到睡眠时间结束或被中断。
    </code>

    为什么线程在访问同步控制块时会进入阻塞状态？
    <code class="ibk">
        当线程访问包含synchronized关键字的代码块（即同步控制块）时，线程需要首先获取该代码块关联对象的锁。为了保证代码的线程安全，Java语言引入了对象锁的概念，每一个对象都具有一个默认的内置锁，当多个线程需要访问同一段同步代码块时，Java虚拟机会控制只能有一个线程拥有该内置锁。
        如果该锁已经被其他线程获得，那么尝试访问同步控制块的线程将无法获取到锁，因而进入阻塞状态。只有当当前持有锁的线程退出同步控制块，从而释放锁时，正在等待的线程才有可能被唤醒并尝试重新获取锁，进入同步控制块。
        这个过程是为了保证线程在执行同步控制块代码的原子性，也就是避免在一个线程执行同步控制块的过程中，另一个线程同时修改了同一段代码操作的数据，从而影响了第一个线程的执行结果。这是实现多线程环境下数据一致性的一个重要手段。
    </code>

    是否有其他方式可以实现线程同步而不使用同步控制块？
    <code class="ibk">
        volatile关键字：=volatile关键字可以确保变量的可见性，当一个变量被声明为volatile之后，意味着线程每次访问变量时都会读取变量修改后的最新值。虽然volatile不执行互斥访问，但它可以保证任何一个线程在读变量时都能看到最新写入的值。
        **锁 (Locks)**：Java
        java.util.concurrent.locks包提供了比synchronized关键字更加复杂的锁机制。比如ReentrantLock，它具有完全互斥的锁定机制，还支持条件变量，能实现更细粒度的线程同步控制。
        **原子变量(java.util.concurrent.atomic)**：该包提供了一系列的原子操作类，例如AtomicInteger，AtomicLong，AtomicReference等，这些类使得执行单一操作的变量更新成为原子操作，进而可以在没有锁的情况下实现线程安全。
        **条件变量
        (Condition)**：条件变量提供了一种线程之间协调通信的方式。比如，通过ReentrantLock创建一个Condition，线程可以在某个条件变量上调用await()方法进入等待状态，直到其他线程在该条件变量上调用signal()或signalAll()方法唤醒等待的线程。
        **并发集合
        (java.util.concurrent包中的集合)**：该包还提供了线程安全的集合类，如ConcurrentHashMap、CopyOnWriteArrayList等，这些集合类中的操作可以安全地并发执行，无需担心线程同步问题。
        Semaphore信号量：信号量用于控制同时访问某个特定资源的操作数量，通过协调各个线程，以保证它们对共享资源的合理使用。
    </code>

    如何使用资源分配图来检测死锁的情况？
    <code class="ibk">
        资源分配图（Resource Allocation Graph,
        RAG）是一种用于解决、预防以及避免死锁的工具。它是一种有向图模型，其中的节点代表系统中的资源和进程，边则表示进程和资源之间的关系。这种关系主要包括两类：请求(request)和分配(allocation)。
        具体来说，该图中的每个节点可以分为两种类型：
        P类型：表示进程。
        R类型：表示资源。
        边的类型主要有两种：
        请求边(Request Edge)：从进程节点到资源节点的有向边，表示一个进程请求某个资源。
        分配边(Allocation Edge)：从资源节点到进程节点的有向边，表示资源已被某个进程占用。
        通过使用资源分配图（RAG），我们可以通过查看图中是否存在环（Cycle）来检测是否存在死锁。基本上，如果图中存在环，那么系统就可能处于死锁状态。但这个规则只适用于每类资源只有一个实例的情况。如果一个资源类可以有多个实例，那么只有当存在一个环，并且环中的每个资源节点都只有一个实例时（即每个资源节点都被环中的其他节点请求），才能确定存在死锁。如果环中某个资源节点有多个实例，那么就不能确定存在死锁，因为可能有一个实例可以被分配给请求它的进程，从而打破环。
        请注意，死锁检测主要应用在运行时，通过动态观察系统的资源分配情况来检测死锁。这种方法主要适用于系统不能避免或预防死锁发生的情况。在系统设计阶段，更推荐将重点放在通过良好的设计来避免死锁发生
    </code>
    <a href="https://blog.csdn.net/nima1994/article/details/65657250">资源分配图化简法-操作系统·死锁</a>

    什么是Java多线程？
    <code class="ibk">
        同一时间内执行多个任务。
    </code>

    如何创建线程？
    <code class="ibk">
        继承Thread类并重写run方法。
        实现Runnable接口并实现run方法，然后将其传递给Thread类的构造函数。
    </code>

    线程的优先级如何设置？
    <code class="ibk">
        线程的优先级范围从1到10，默认为5。可以使用setPriority方法设置线程的优先级，但优先级并不保证一定会影响线程调度顺序，因为具体的实现可能会受到操作系统和硬件的影响。
    </code>

    线程和进程的区别是什么？
    <code>
        进程是独立的，有自己的资源和空间；线程是进程内的小部分，共享进程的资源。
        进程间通信相对复杂，需要特殊的机制；线程间通信相对简单，可以直接共享内存。
        创建和销毁进程的开销比较大；创建和销毁线程的开销比较小。
    </code>

    实现进程间通信
    <code>
        进程间通信（IPC）是指不同进程之间进行数据交换和通信的机制。在操作系统中，有多种方式可以实现进程间通信，常见的包括：

        1. **管道（Pipe）**：
        - **描述**：管道是一种单向通信方式，通常用于具有亲缘关系（父子进程）的进程间通信。
        - **特点**：管道只能实现单向通信，且数据在管道中是先进先出的。
        - **适用场景**：适合用于父子进程之间的通信，比如父进程向子进程发送数据或者接收子进程的输出。

        2. **命名管道（Named Pipe）**：
        - **描述**：类似于普通管道，但具有独立的文件路径名，允许无亲缘关系的进程进行通信。
        - **特点**：命名管道可以跨越无关的进程，但仍然是单向通信。
        - **适用场景**：适合用于无关进程之间需要进行通信的场景，比如不同用户的进程间通信。

        3. **消息队列（Message Queue）**：
        - **描述**：消息队列允许进程通过发送和接收消息来进行通信。
        - **特点**：消息队列可以实现多对多的通信，消息的顺序可以是先进先出或者按优先级。
        - **适用场景**：适合用于需要异步通信、支持多对多通信以及需要按照特定顺序处理消息的场景。

        4. **共享内存（Shared Memory）**：
        - **描述**：共享内存允许多个进程共享同一块物理内存空间，进程可以直接读写共享内存中的数据。
        - **特点**：共享内存的速度快，但需要额外的同步机制来避免数据竞争和一致性问题。
        - **适用场景**：适合用于需要高性能、大量数据交换的场景，比如图像处理、数据库等。

        5. **信号量（Semaphore）**：
        - **描述**：信号量是一种计数器，用于控制对共享资源的访问，防止多个进程同时访问导致的数据不一致。
        - **特点**：信号量可以用来实现进程间的同步和互斥，防止竞态条件和死锁。
        - **适用场景**：适合用于控制并发访问共享资源的场景，比如资源池管理、进程同步等。

    </code>

    线程状态之间的转换
    <code class="ibk">
        新建状态（New） -> 就绪状态（Runnable）：调用start方法启动线程。
        就绪状态（Runnable） -> 运行状态（Running）：获取CPU执行时间开始运行。
        运行状态（Running） -> 就绪状态（Runnable）或阻塞状态（Blocked）或终止状态（Terminated）：
        就绪状态：调用yield方法或者等待CPU时间片结束。
        阻塞状态：等待某个条件满足，比如I/O操作完成。
        终止状态：run方法执行完毕或者因为异常退出。
        等待状态（Waiting）或超时等待状态（Timed Waiting）：
        调用Object.wait()、Thread.join()、LockSupport.park()等方法进入等待状态。
        调用Thread.sleep()、Object.wait(timeout)、LockSupport.parkNanos()等方法进入超时等待状态。
        等待其他线程唤醒或者等待指定时间后返回到就绪状态或者阻塞状态。
    </code>

    请解释一下什么是Java内存模型（JMM）以及它是如何工作的。
<code class="ibk">
    Java内存模型（Java Memory Model，JMM）定义了Java程序中多线程并发访问共享变量时的内存行为规范，确保在多线程环境下程序的正确性、可见性和一致性。JMM主要规定了以下几个方面：

    1. **主内存（Main Memory）**：
    - 主内存是所有线程共享的内存区域，存储了共享变量的值。
    - 所有的变量（包括实例变量、静态变量和数组元素）都存储在主内存中。

    2. **工作内存（Working Memory）**：
    - 每个线程都有自己的工作内存，工作内存中存储了主内存中某些变量的副本。
    - 线程对变量的操作必须在工作内存中进行，而不是直接在主内存中操作变量。

    3. **内存间交互操作**：
    - 线程对变量的读写操作都必须通过主内存进行。
    - 线程在进行读操作时，首先将变量的值从主内存复制到工作内存中；在进行写操作时，先修改工作内存中的值，然后将修改后的值写回到主内存中。

    4. **内存可见性**：
    - 当一个线程修改了某个共享变量的值后，其他线程能够立即看到修改后的值，这称为内存可见性。
    - 通过volatile关键字和synchronized关键字可以实现对共享变量的内存可见性保证。

    5. **顺序性一致性**：
    - Java内存模型保证程序的执行结果与指令顺序一致，即按照程序中的顺序执行指令。
    - 通过volatile关键字、synchronized关键字和Lock接口等可以实现顺序性一致性的保证。

    JMM通过定义了各种操作的内存间交互规则和内存可见性规则，保证了多线程环境下程序的正确性和一致性。在实际编程中，开发者需要了解JMM的规范，并且采取合适的同步机制（比如使用volatile、synchronized、Lock等）来保证共享变量的正确访问和操作。
</code>

</div>

<link href="style/styles.css" rel="stylesheet">
<script src="js/script.js"></script>

</body>
</html>